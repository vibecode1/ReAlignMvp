import { jsPDF } from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';
import { drizzle } from 'drizzle-orm/node-postgres';
import pkg from 'pg';
const { Pool } = pkg;
import * as schema from '@shared/schema';
import { loe_drafts, transactions, users } from '@shared/schema';
import { eq } from 'drizzle-orm';
import fs from 'fs/promises';
import path from 'path';

// Initialize database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  },
});

const db = drizzle(pool, { schema });

export class LoeExportService {
  // Export LOE to PDF
  async exportToPdf(draftId: string): Promise<Buffer> {
    try {
      const [draft] = await db
        .select({
          draft: loe_drafts,
          transaction: transactions,
          creator: users,
        })
        .from(loe_drafts)
        .leftJoin(transactions, eq(loe_drafts.transaction_id, transactions.id))
        .leftJoin(users, eq(loe_drafts.created_by_user_id, users.id))
        .where(eq(loe_drafts.id, draftId));

      if (!draft) {
        throw new Error('LOE draft not found');
      }

      // Create PDF
      const doc = new jsPDF();
      
      // Set font
      doc.setFontSize(12);
      
      // Add title
      doc.setFontSize(16);
      doc.text(draft.draft.letter_title, 20, 20);
      
      // Add metadata
      doc.setFontSize(10);
      doc.text(`Transaction: ${draft.transaction?.title || 'N/A'}`, 20, 35);
      doc.text(`Property: ${draft.transaction?.property_address || 'N/A'}`, 20, 42);
      doc.text(`Created: ${new Date(draft.draft.created_at).toLocaleDateString()}`, 20, 49);
      
      // Add letter content
      doc.setFontSize(12);
      const lines = doc.splitTextToSize(draft.draft.letter_content, 170);
      let y = 65;
      
      lines.forEach((line: string) => {
        if (y > 270) {
          doc.addPage();
          y = 20;
        }
        doc.text(line, 20, y);
        y += 7;
      });

      // Add footer
      doc.setFontSize(8);
      doc.text(`Generated by ReAlign - Version ${draft.draft.current_version}`, 20, 285);

      // Update export tracking
      await this.updateExportTracking(draftId, 'pdf');

      return Buffer.from(doc.output('arraybuffer'));
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      throw error;
    }
  }

  // Export LOE to Word document
  async exportToWord(draftId: string): Promise<Buffer> {
    try {
      const [draft] = await db
        .select({
          draft: loe_drafts,
          transaction: transactions,
        })
        .from(loe_drafts)
        .leftJoin(transactions, eq(loe_drafts.transaction_id, transactions.id))
        .where(eq(loe_drafts.id, draftId));

      if (!draft) {
        throw new Error('LOE draft not found');
      }

      // Create document
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            // Title
            new Paragraph({
              text: draft.draft.letter_title,
              heading: HeadingLevel.HEADING_1,
              spacing: { after: 200 },
            }),
            
            // Metadata
            new Paragraph({
              children: [
                new TextRun({
                  text: `Transaction: ${draft.transaction?.title || 'N/A'}`,
                  size: 20,
                }),
              ],
              spacing: { after: 100 },
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Property: ${draft.transaction?.property_address || 'N/A'}`,
                  size: 20,
                }),
              ],
              spacing: { after: 100 },
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Date: ${new Date(draft.draft.created_at).toLocaleDateString()}`,
                  size: 20,
                }),
              ],
              spacing: { after: 400 },
            }),
            
            // Letter content - split by paragraphs
            ...draft.draft.letter_content.split('\n\n').map(paragraph => 
              new Paragraph({
                text: paragraph,
                spacing: { after: 200 },
              })
            ),
            
            // Footer
            new Paragraph({
              children: [
                new TextRun({
                  text: `Generated by ReAlign - Version ${draft.draft.current_version}`,
                  size: 16,
                  italics: true,
                }),
              ],
              spacing: { before: 400 },
            }),
          ],
        }],
      });

      const buffer = await Packer.toBuffer(doc);
      
      // Update export tracking
      await this.updateExportTracking(draftId, 'docx');

      return buffer;
    } catch (error) {
      console.error('Error exporting to Word:', error);
      throw error;
    }
  }

  // Export LOE to plain text
  async exportToText(draftId: string): Promise<string> {
    try {
      const [draft] = await db
        .select({
          draft: loe_drafts,
          transaction: transactions,
        })
        .from(loe_drafts)
        .leftJoin(transactions, eq(loe_drafts.transaction_id, transactions.id))
        .where(eq(loe_drafts.id, draftId));

      if (!draft) {
        throw new Error('LOE draft not found');
      }

      const text = `${draft.draft.letter_title}
================================================================================

Transaction: ${draft.transaction?.title || 'N/A'}
Property: ${draft.transaction?.property_address || 'N/A'}
Date: ${new Date(draft.draft.created_at).toLocaleDateString()}

================================================================================

${draft.draft.letter_content}

================================================================================
Generated by ReAlign - Version ${draft.draft.current_version}
`;

      // Update export tracking
      await this.updateExportTracking(draftId, 'txt');

      return text;
    } catch (error) {
      console.error('Error exporting to text:', error);
      throw error;
    }
  }

  // Update export tracking
  private async updateExportTracking(draftId: string, format: string) {
    try {
      const [draft] = await db
        .select()
        .from(loe_drafts)
        .where(eq(loe_drafts.id, draftId));

      if (draft) {
        const currentFormats = draft.export_formats || [];
        if (!currentFormats.includes(format)) {
          currentFormats.push(format);
        }

        await db
          .update(loe_drafts)
          .set({
            export_formats: currentFormats,
            last_exported_at: new Date(),
            updated_at: new Date(),
          })
          .where(eq(loe_drafts.id, draftId));
      }
    } catch (error) {
      console.error('Error updating export tracking:', error);
    }
  }

  // Save exported file temporarily for download
  async saveExportedFile(content: Buffer | string, filename: string, format: string): Promise<string> {
    try {
      const uploadsDir = path.join(process.cwd(), 'tmp', 'exports');
      await fs.mkdir(uploadsDir, { recursive: true });

      const filepath = path.join(uploadsDir, `${filename}.${format}`);
      
      if (typeof content === 'string') {
        await fs.writeFile(filepath, content, 'utf8');
      } else {
        await fs.writeFile(filepath, content);
      }

      return filepath;
    } catch (error) {
      console.error('Error saving exported file:', error);
      throw error;
    }
  }
}

export const loeExportService = new LoeExportService();